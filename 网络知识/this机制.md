### this
作用域链和 this 是两套不同的系统，它们之间基本没太多联系。
this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。
执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。
### 全局上下文的this
全局执行上下文中的 this 是指向 window 对象的，严格模式下，this为undefined。
这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。
### 函数执行上下文中的 this
- 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
- 通过对象调用方法设置
使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
- 通过函数的 call/apply/bind方法设置
- 通过构造函数中设置
通过 new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。
### new做了什么
new 关键字会进行如下的操作：

创建一个空的简单JavaScript对象（即{}）；
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；
将步骤1新创建的对象作为this的上下文；
如果该函数没有返回对象，则返回this。
### this的设计缺陷
1. 嵌套函数中的 this 不会从外层函数中继承
- 解决方法
  + 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
  + 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。
2. 普通函数中的 this 默认指向全局对象 window


如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。


fun.call(null) 调用的是默认绑定
严格模式下是null，非严格模式下是window
