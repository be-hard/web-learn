## HTTP
超文本传输语言，是浏览器和服务器之间的通信语言。基于请求响应的模式，从客户端发出请求，服务器返回数据。
明文传输，基于TCP协议。
是五层协议中的应用层

### TCP/IP五层协议及功能
- 物理层
传输数据的载体介质，如光纤、电缆等，透明地传输比特流
- 数据链路层
向上传输物理层传递过来的数据或者向下传输网络层传递的数据，并对数据进行处理，将网络层传输的IP数据包包装成帧，添加控制信息，目的地址、源地址、类型。还有帧的编码和错误纠正控制。
- 网络层
端与端之间数据透明传输传输的协议，通过IP寻址来建立两个节点之间的连接。
将报文段或用户数据报分组或分包进行传送。使用IP协议，产生的数据报也叫IP数据包。
还有一个功能：选择合适的路由
- 传输层
UDP和TCP协议
负责两个主机进程间的通信服务。有复用和分用的功能，多个应用层进程可以同时复用运输层的服务，分用就是把收到的信息分发给应用层对应的进程。
- 应用层
为用户应用程序直接提供各种服务
如HTTP，电子邮件的SMTP协议、文件传送的FTP协议、DNS协议、SNMP，Telnet等等
#### HTTP0.9
- 只有一个请求行，并没有 HTTP 请求头和请求体
- 用来在网络之间传递 HTML 超文本的内容，
- 返回的文件内容是以 ASCII 字符流来传输的
![](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)
#### HTTP1.0
- 支持多种类型的文件下载
- 文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件
- 客户端和服务端通过请求头和响应头来进行协商
在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码
- 状态码
- 为了减轻服务器的压力，提供了 Cache 机制
- 用户代理
![](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)
#### HTTP1.1
- 增加了持久连接
一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。
减少了服务器额外的负担，并提升整体 HTTP 的请求时长
如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。
- 不成熟的 HTTP 管线化
持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题
HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。
- 提供虚拟主机的支持
增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。
- 对动态生成的内容提供了完美支持
通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。
- 客户端 Cookie、安全机制

存在的问题
- 对带宽的利用率却并不理想
带宽是指每秒最大能发送或者接收的字节
原因：
+ TCP 的慢启动
一旦 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。
慢启动是 TCP 为了减少网络拥塞的一种策略
+ 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽
为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。
+ 队头阻塞的问题

慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。
### HTTP2
HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
- 多路复用机制
HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。
HTTP/2 添加了一个二进制分帧层。
首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
- 可以设置请求的优先级
可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求
- 服务器推送
当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。
- 头部压缩

### HTTP3
- HTTP/2 解决了应用层面的队头阻塞问题，但没有解决传输层TCP队头阻塞的问题

从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。
如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。

在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

- TCP 建立连接的延时
TCP 的握手过程也是影响传输效率的一个重要因素
#### 网络延迟
我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。

如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。

- 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
- 总之，在传输数据之前，我们需要花掉 3～4 个 RTT

如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了

#### TCP协议僵化
- 中间设备的僵化
这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。

#### QUIC 协议
HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议
- 实现了类似 TCP 的流量控制、传输可靠性的功能
- 集成了 TLS 加密功能
- 实现了 HTTP/2 中的多路复用功能
- 实现了快速握手功能
QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。

设备对 UDP 的优化程度远远低于 TCP
## HTTPS
### HTTP 协议栈中引入安全层
HTTP 是明文传输数据的，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中。
我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。
HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。
![](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

### 对称加密
对称加密是指加密和解密都使用的是相同的密钥。
HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥
![](https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png)
- 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。
- 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。最后浏览器和服务器分别返回确认消息。
- 然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了
存在的问题：
传输 client-random 和 service-random 的过程是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。
### 非对称加密
非对称加密就是加密和解密用不同的秘钥，假设有 A、B 两把密钥，如果用 A 密钥来加密，那么只能使用 B 密钥来解密；
HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。
![](https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png)
采用非对称加密，就能保证浏览器发送给服务器的数据是安全的
存在的问题：
- 无法保证服务器发送给浏览器的数据安全
- 非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。
### 对称加密和非对称加密搭配使用
在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输
![](https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png)
- 浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
- 服务器保存随机数client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；
- 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
- 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。
- 服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了

> pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。
存在的问题：
比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。
所以需要服务器向浏览器提供证明“我就是我”
### 添加数字证书
使用权威机构颁发的证书，这个权威机构称为 CA（Certificate Authority），颁发的证书就称为数字证书（Digital Certificate)。
数字证书的作用：
- 一个是通过数字证书向浏览器证明服务器的身份
- 另一个是数字证书里面包含了服务器公钥
![](https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png)
服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。
### 如何申请证书
- 极客时间需要准备一套私钥和公钥，私钥留着自己使用；
- 然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；
- CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。
> CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名。
### 浏览器如何验证数字证书
浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。
### CA是否可信
这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。

#### 三种刷新操作对 http 缓存的影响
正常操作：地址栏输入 url，跳转链接，前进后退等。
手动刷新：f5，点击刷新按钮，右键菜单刷新。
强制刷新：ctrl + f5，shift+command+r。

正常操作：强制缓存有效，协商缓存有效。
手动刷新：强制缓存失效，协商缓存有效。
强制刷新：强制缓存失效，协商缓存失效。


websocket？