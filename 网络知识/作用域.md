### 作用域
作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
### ES作用域
- 全局作用域
对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域
函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
- 块级作用域  
ES6后支持。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。作用域块内声明的变量不影响块外面的变量。
### 为什么会有变量提升？
最初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。
### 变量提升带来的问题
JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷
- 变量覆盖
```
var myname = "极客时间"function showName(){ console.log(myname); if(0){ var myname = "极客邦" } console.log(myname);}showName()
```
- 变量污染
```
function foo(){ for (var i = 0; i < 7; i++) { } console.log(i); }foo()
```
本应销毁的变量没有被销毁
### ES6如何解决
ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。
#### let和const的区别
两者之间的区别是，使用 let 关键字声明的变量是可以被改变的，而使用 const 声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域，
#### JavaScript 是如何支持块级作用域的
ES6 是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？
```
function foo(){ 
  var a = 1 
  let b = 2 
  { 
    let b = 3 
    var c = 4 
    let d = 5 
    console.log(a) 
    console.log(b) 
  } 
    console.log(b) 
    console.log(c) 
    console.log(d)
  } 
foo()
```
- 第一步是编译并创建执行上下文  
函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。在函数内部的作用域块中，通过 let 声明的变量并没有被存放到词法环境中。
![](https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png)
- 第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2    
当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量

![](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)
#### 词法环境的结构
在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。
- 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。
- 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：
![](https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png)

```
let myname= '极客时间'
{ 
  console.log(myname) 
  let myname= '极客邦'
}
```
【最终打印结果】：VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization
【分析原因】：在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
【拓展】
var的创建和初始化被提升，赋值不会被提升。
let的创建被提升，初始化和赋值不会被提升。
function的创建、初始化和赋值均会被提升。
### 扩展
#### 块级作用域是否有编译过程
执行函数时才有进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”；

暂时性死去是语法规定的，也就是说虽然通过let声明的变量已经在词法环境中了，但是在没有赋值之前，访问该变量JavaScript引擎就会抛出一个错误。V8虚拟机做了限制，虽然a在内存中，但是当你在let a 之前访问a时，根据ECMAScript定义，虚拟机会阻止的访问！


### 问题
console.log(a)
{
  function a(){}
}
打印出来是undefined
#### 回答
ES规定函数不能在块级作用域中声明，
function foo(){
    if(true){
        console.log(&#39;hello world&#39;);
        function g(){ return true; }
    }
}
也就是说，上面这行代码执行会报错，但是个大部分浏览器都没有遵守这个标准。

接下来到了ES6了，ES6明确支持块级作用域，ES6规定块级作用域内部声明的函数，和通过let声明变量的行为类似。

规定的是理想的，但是还要照顾实现，要是完全按照let的方式来修订，会影响到以前老的代码，所以为了向下兼容，大部分浏览器基本是按照下面的方式来实现的：

function foo(){
    if(true){
        console.log(&#39;hello world&#39;);
        var g = function(){return true;}
    }
}

这就解释了你的疑问，不过还是不建议在块级作用域中定义函数，很多时候，简单的才是最好的。

