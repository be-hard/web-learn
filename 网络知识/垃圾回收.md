### 1. 什么是垃圾数据，为什么要进行垃圾回收
数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，而内存空间是有限的，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间
### 2. 如何进行垃圾回收？
不论什么类型的垃圾回收器，它们都有一套共同的执行流程
- 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
从根节点（Root）出发，遍历所有的对象。
可以遍历到的对象，是可达的（reachable）。
没有被遍历到的对象，不可达的（unreachable）。
在浏览器环境下，根节点有很多，主要包括这几种：
全局变量 window，位于每个 iframe 中
文档 DOM 树
存放在栈上的变量
...
这些根节点不是垃圾，不可能被回收。
- 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
- 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，(但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。)
### 3. 什么时候进行垃圾回收？
由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂停时间很长就会造成页面卡顿。
### 分代收集
浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象。
临时对象：
大部分对象在内存中存活的时间很短。
比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。
这类对象很快就变得不可访问，应该快点回收。
长久对象：
生命周期很长的对象，比如全局的 window、DOM、Web API 等等。
这类对象可以慢点回收。

这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域， 新生代中存放临时对象，老生代中存放持久对象。并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。
### 副垃圾回收器
新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是**把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。**
![](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)
新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。
- 先给对象区域所有垃圾做标记。
- 标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。(这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。)
- 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。
**因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。**
### 主垃圾回收器
老生区中的对象有两个特点：一个是对象占用空间大，另一个是对象存活时间长。

主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

（由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间）
- 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
- 然后是垃圾清除
- 多次标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理

这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。
### 增量收集
可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。
### 闲时收集
垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
### 4. 浏览器中不同类型变量的内存都是何时释放？
Javascritp 中类型：值类型，引用类型。
- 引用类型
在没有引用之后，通过 V8 自动回收。
- 值类型
如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收。
非闭包的情况下，等待 V8 的新生代切换的时候回收。
### 5. 哪些情况会导致内存泄露？如何避免？
> 内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。
以 Vue 为例，通常有这些情况：
监听在 window/body 等事件没有解绑
绑在 EventBus 的事件没有解绑
Vuex 的 $store，watch 了之后没有 unwatch
使用第三方库创建，没有调用正确的销毁函数
解决办法：beforeDestroy 中及时销毁
绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
观察者模式 $on，$off处理。
如果组件中使用了定时器，应销毁处理。
如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
使用弱引用 weakMap、weakSet。
### 6. 闭包会导致内存泄露吗？
闭包会导致内存泄露吗？正确的答案是不会。
内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。
闭包里面的变量就是我们需要的变量，不能说是内存泄露。
> 这个误解是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。参考这篇文章
### 7. weakMap weakSet 和 Map Set 有什么区别？

在 ES6 中为我们新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。
它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。
只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。
也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。