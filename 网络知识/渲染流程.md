### 2. 渲染流程
![](https://static001.geekbang.org/resource/image/31/e6/31cd7172f743193d682d088a60cb44e6.png)
流水线可以分为以下几个阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成
#### 构建DOM树
因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 通过HTML解析器转换为浏览器能够理解的结构——DOM 树。
> 这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点
#### 样式计算
1. 把 CSS 转换为浏览器能够理解的结构 —— styleSheets
第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。
并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
![CSS的来源](https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png)
从图中可以看出，CSS 样式来源主要有三种：
- 通过 link 引用的外部 CSS 文件
- 通过style标签内的CSS
- 元素内嵌的style属性
2. 转换样式表中的属性值，使其标准化
2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。如果引用节点为 null，则将指定的节点添加到指定父节点的子节点列表的末尾。
3. 计算出 DOM 树中每个节点的具体样式
这个就涉及到 CSS 的继承规则和层叠规则了。
CSS 继承就是每个 DOM 节点都包含有父节点的样式。特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。
层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
>css 文件也是一边下载一边解析的
**样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则**
渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

#### 布局阶段
计算出 DOM 树中**可见元素**的几何位置，并将这些信息保存在布局树中。我们把这个计算过程叫做布局。

1. 创建布局树
在显示之前，我们还要额外地构建一棵只包含可见元素布局树。
+ 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
+ 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

2. 布局计算
计算布局树节点的坐标位置

#### 分层
1 生成图层树
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
#### 需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。
- 第一点，拥有层叠上下文属性的元素会被提升为单独的一层
页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念。
+ 文档根元素（<html>）；
+ position 值为 absolute（绝对定位）或  relative（相对定位）且 z-index 值不为 auto 的元素；
+ position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；
+ flex (flexbox (en-US)) 容器的子元素，且 z-index 值不为 auto；
+ grid (grid) 容器的子元素，且 z-index 值不为 auto；
+ opacity 属性值小于 1 的元素（参见 the specification for opacity）；
+ mix-blend-mode 属性值不为 normal 的元素；
以下任意属性值不为 none 的元素：
+ transform
+ filter
+ perspective
+ clip-path
+ mask / mask-image / mask-border
+ isolation 属性值为 isolate 的元素；
+ -webkit-overflow-scrolling 属性值为 touch 的元素；
+ will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考这篇文章）；
+ contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。
- 第二点，需要剪裁（clip）的地方也会被创建为图层。
如果出现滚动条，滚动条也会被提升为单独的层。
#### 图层绘制
在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制.
把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
#### 栅格化（raster）操作
绘制列表只是用来记录绘制顺序和绘制指令的列表,实际上绘制操作是由渲染引擎中的合成线程来完成的.
合成线程会将图层划分为图块.合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图.渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的.
栅格化过程都会使用 GPU 来加速生成。使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。
> 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
![](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)
#### 合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程
浏览器进程根据 DrawQuad 命令,将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

### 总结
- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### 3. js css 顺序对前端优化影响

- CSS文件一般放在前面，布局树的生成需要DOM树和stylesheet，如果 css 文件放在尾部，那么整个过程就是一个串行的过程先解析了 dom，再去解析 css。这样 DOM 树和 stylesheet的构建就变成同步进行了。这样生成页面的时间就变长了。如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑直到CSS加载完成。

- JS 脚本一般放在尾部。
+ JS 代码会有操作 dom 节点的情况，如果放在头部执行，DOM树还没有构建，拿不到 DOM 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉。
+ 在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。所以js文件放在后面，可能执行JS的时候CSSOM已经生成了，就不需要等待。


### 优化
- 其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。
- 比如使用 CDN 来加速 JavaScript 文件的加载，
- 压缩 JavaScript 文件的体积。
- 如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。
