### 重排重绘
#### 更新了元素的几何属性（重排）
重排需要更新完整的渲染流水线，所以开销也是最大的。
![](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)
#### 更新元素的绘制属性（重绘）
如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘.
重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
![](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)
获取元素的几何属性也会触发重排
### 合成

如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。（比如CSS3的实现的一些动画效果）
因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。


### 滚动是否会触发重排？
 现代浏览器做了优化，把滚动操作交给了合成线程来处理，也就是说滚动的内容会被当成一个单独的图层，发生滚动的事件的时候，图层直接由合成线程来生成，也就是说这种情况下没有占用主线程，所以通常情况下不会产生重排和重回操作，只是简单合成就可以了，这样效率是最高的！
为什么说“通常”呢？ 这是因为目前渲染流程还是很复杂的，在滚动页面时，有些情况下，如果合成线程搞不定的，那么还要交给主线程去处理，这时候就涉及到重拍了，不过技术是往前发展的，渲染流程会变得越来约简单高效！
### 避免方法
- js 尽量减少对样式的操作，能用 css 完成的就用 css，(使用 class 操作样式，而不是频繁操作 style)
- 对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用
- 如果必须要用 js 操作样式，能合并尽量合并不要分多次操作.
- 对 dom 属性的读写要分离 
- resize 事件 最好加上防抖，能尽量少触发就少触发
- 加载图片的时候，提前写好宽高
-  will-change: transform 做优化