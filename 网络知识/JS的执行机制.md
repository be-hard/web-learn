### 执行机制
JavaScript 的执行机制：先编译，再执行。
在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；（它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 函数名 的属性，然后将该属性值指向堆中函数的位置）
在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。


下面是关于同名变量和函数的两点处理原则：

1:如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。

2:如果变量和函数同名，那么在编译阶段，变量的*声明*会被忽略

执行阶段该覆盖的还是会覆盖

### 调用栈
调用栈就是用来管理函数调用关系的一种数据结构。通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。
#### 创建执行上下文的三种情况
- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。
### 函数调用
函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号
### 代码执行过程
```
var a = 2;
function add(b,c){ return b+c}
function addAll(b,c){
  var d = 10;
  result = add(b,c);
  return a+result+d;
}
addAll(3,6);
```
第一步，创建全局上下文，并将其压入栈底
第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中
第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，
当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值
addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。
#### 总结
每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。
### 如何利用浏览器查看调用栈的信息
1、开发者工具
你可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在第 n 行加上断点，并刷新页面。你可以看到执行到当前断点的代码时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：
![](https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png)
2、使用 console.trace() 来输出当前的函数调用关系

#### 为什么使用定时器可以解决栈移除问题？
 function foo() { setTimeout(foo, 0) } foo() 像setTimeout 、setInterval Promise 这样的全局函数不是js 的一部分，而是webapi 部分。 当遇到webApi 时，会将其回调函数(foo)交给web apis 处理，此时 调用栈 中foo 函数执行完毕，出栈，栈为空； 回调函数会被发送到任务队列中，等待event loop 事件循环将其捞出 重新放入到堆栈中



调用栈是后进先出，那么当存在闭包时，某个函数的执行上下文还存在，那么其他函数的出栈是否受影响？