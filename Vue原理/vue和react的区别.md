### Vue和react
共同点：
都有组件化，实现了视图的复用
都是数据驱动视图
都是单向数据流
都是通过Vitual Dom操作Dom
社区成熟，都支持SSR


从使用习惯和思维模式来说，Vue可能更接近传统的web开发习惯，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。Vue对于新手更好上手，很多东西都帮我们封装好了，只需要按照规定的语法和配置就可以。而react特色在于函数式编程和丰富的技术选型，很多东西需要开发者自己实现或者根据需要引入第三方库，对于原生JS要求高一点。all in js，html也是通过JSX的写法，css的模块化也是用JS的写法。react做优化的上限大一点

从实现上看，最大的不同是数据的响应式。Vue的响应式是数据改变了，界面就会自动更新。而react需要开发者调用setState触发界面的更新。尤雨溪把这两种分别 称为push-based和pull-based.push-based就是改动数据之后，数据本身会把这个改动推送出去，告知渲染系统自动进行渲染。而pull-based就是用户需要主动明确的告知系统需要重新渲染，此时系统才会重新渲染。
两者并没有绝对的优劣之分，更多的也是思维模式和开发习惯的不同。两者也不似互斥的，在Vue也可以通过将数据freeze，让数据不具有响应式的特点，然后手动调用更新组件的方法实现pull-based.在react也可以通过引入第三方库比如MobX实现push-based的系统。

### 异步更新队列
在项目中我们常常会遇到这样的情景，我们更新了数据，然后想获取更新后的DOM，发现获取的往往是旧的DOM.这是因为Vue中采用的是异步更新.
异步更新就是当数据发生改变时,并不会立刻去更新渲染,而是把渲染任务放到异步更新队列中,并且会进行去重,如果队列中已经存在这个任务,则不会将渲染任务放进队列。然后会在本轮事件循环的最后或者下一轮事件循环中（不支持创建微任务时）执行队列中的所有渲染操作并清空队列。
Vue优先将渲染任务作为微任务，如果执行环境不支持，则是宏任务。
#### 事件循环
JS中存在一个叫做执行栈的东西。JS的所有同步代码都在这里执行，当执行一个函数调用时，会创建一个新的执行环境并压到栈中开始执行函数中的代码，当函数中的代码执行完毕后将执行环境从栈中弹出，当栈空了，也就代表执行完毕。

这里有一个问题是代码中不只是同步代码，也会有异步代码。当一个异步任务执行完毕后会将任务添加到任务队列中，异步队列也分两种类型：微任务、宏任务队列。v8为每个宏任务创建一个为任务队列，宏任务执行过程中的产生的微任务会加入微任务队列中，在宏任务执行结束前会检查微任务队列，如果不为空，则会按顺序取出执行。任务队列空了之后再从宏任务队列中拿出来一个任务执行。这样持续的交替执行任务叫做事件循环。

属于微任务（microtask）的事件有以下几种：

Promise.then
MutationObserver
Object.observe
process.nextTick
属于宏任务（macrotask）的事件有以下几种：

setTimeout
setInterval
setImmediate
MessageChannel
requestAnimationFrame
I/O
UI交互事件

#### 如何获取更新后的DOM
可以在数据更改后，在微任务中获取
this.$nextTick(()=>{

})
或者在宏任务中获取，因为宏任务是在下一轮循环中执行的，此时渲染任务是微任务，肯定比宏任务先执行。
setTimeout(()=>{

},0)
