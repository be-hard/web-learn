### Node.js非阻塞I/O
- I/O即系统的输入和输出
- 阻塞和非阻塞的区别在于系统在接受输入到输出期间能不能接受其他的输入

举个例子，我们去外面吃饭，碰到的一般有两种服务的模式，一种是食堂排队打饭，另一种是餐厅点菜模式，对于服务员或者打饭的阿姨来说，前者是阻塞I/O，因为在前面一个人点菜到拿到菜的过程中，服务员不能去处理其他人的点菜，而后者是非阻塞I/O，当前顾客点完菜后，在厨房菜做好的期间，服务员可以处理其他顾客的点菜。

### 获取程序运行时间
console.time('name')
console.timeEnd('name')
### callback参数的规范
第一个参数是错误信息，后面的才是执行的结果
第一个参数不为null,说明有错误

### 为什么try/catch捕获不到setTimeout抛出的错误
try/catch和throw和调用栈有很大的关系
#### 调用栈
我们的代码会有函数调用函数的情况，每一个函数调用其他函数，进入其他函数的时候，它会在调用栈里面再加一层，然后一层一层累加上去，形成了一个调用的链条关系。在程序里面就形成了一个栈。每往深处调用一次，这个栈就会在上面加多一个元素，
#### try/catch
比如在栈顶抛出错误，错误的流向是，先抛出栈顶第一个元素，如果没有被捕获，继续抛到栈顶的第二个元素，没有继续往上跑，直到被捕获，如果到了栈底仍然没有被捕获，则抛到全局，程序崩溃。
如果throw语句不是在try/catch包裹的调用里，它就不会被try/catch捕获
因为setTimeout里的回调函数是在下一个事件循环中调用的，每一个事件循环都是一个全新的调用栈，所以setTimeout和外面的try/catch不再同一个调用栈里，所以try/catch捕获不到setTimeout回调函数中抛出的错误。
#### 总结
在一个异步任务里面throw一个错误是不能被外面的try/catch所捕获到的
### 异步编程
#### callback
问题：异步流程控制问题
- 异步串行，回调地狱的问题
- 异步并发


### 事件循环