### 为什么0.1+0.2===0.3是false

### 浮点数
计算机就算有再大的内存也存储不了一个无限的数，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题。
可以认为浮点数就是小数，在JS中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码，这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特

64位比特又可分为三个部分：

符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023
尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

#### 再来一个问题，那么为什么x=0.1得到0.1？
但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：

0.1.toPrecision(21) = 0.100000000000000005551

计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法

因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差

JavaScript 存储小数和其它语言如 Java 和 Python 都不同，JavaScript 中所有数字包括整数和小数都只有一种类型 即 Number类型 它的实现遵循 IEEE 754 标准

