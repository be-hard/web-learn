#### 命令式编程
着眼于过程，分解过程步骤编程，需要从头读到尾才能知道代码具体做了什么
#### 函数式编程
着眼于函数，强调如何通过函数的组合变换去解决问题，而不是我通过写什么样的语句去解决问题。可读性强。
函数实际上是一个关系，或者说是一种映射，映射关系是可以组合的，就像数学上的g(f) = g(f(x)).强调在编程过程中把更多的关注点放在如何去构建关系。通过构建一条高效的建流水线，一次解决所有问题。而不是把精力分散在不同的加工厂中来回奔波传递数据。

#### 核心概念
 - 数据不可变
 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。
 - 无状态
 强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化

函数式编程提出函数应该具备的特性：没有副作用和纯函数

#### 没有副作用
副作用的含义是：在完成函数主要功能之外完成的其他副要功能。对于函数来说，主要的功能就是根据输入返回结果。在函数中最常见的副作用就是随意的操纵外部的变量。对于对象，我们传递的是引用地址，通过引用地址修改是会改动到外部的变量。

#### 纯函数
- 不依赖外部状态（无状态）： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。
- 没有副作用（数据不变）： 不修改全局变量，不修改入参。

#### 纯函数的意义
- 便于测试和优化
由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。代码的健壮性更强。
- 可缓存函数结果
因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。对于像 fibonacci 这种计算，就可以起到很好的缓存效果。
- 更少的 Bug
使用纯函数意味着你的函数中不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。

### 函数式编程的两大操作
函数柯里化和函数组合是函数式编程的两大操作，柯里化可以认为是流水线上的加工站，函数组合是流水线，由多个加工站组成

### 函数柯里化
curry
柯里化的意思是将一个多元函数，转换成一个依次调用的单元函数。
函数的返回值，有且只有一个嘛？ 如果我们想顺利的组装流水线，那我就必须保证我每个加工站的输出刚好能流向下个工作站的输入。因此，在流水线上的加工站必须都是单元函数。

#### 部分函数应用
柯里化强调的是生成单元函数，部分函数应用的强调的固定任意元参数，而我们平时生活中常用的其实是部分函数应用，这样的好处是可以固定参数，降低函数通用性，提高函数的适合用性。

#### 高级柯里化
根据参数的个数，返回柯里化函数或者结果。即如果传入的参数数量满足了条件，则返回结果，否则返回柯里化函数。

单值函数是我们即将讲到的函数组合的基础。
柯里化中规范是把要操作的数据放到最后

### 函数组合
函数组合的目的是将多个函数组合成一个函数。
compose是满足结合律的，只要顺序一致，最终的结果都是一样的。
一个程序只实现一个功能，多个程序组合完成复杂任务。
好处：
它让代码变得简单而富有可读性，同时可以通过不同的组合方式，轻易组合出其他常用函数

性能：
1、函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销。同时，在 JS 这种非函数式语言中，函数式的方式必然会比直接写语句指令慢（引擎会针对很多指令做特别优化）。就拿原生方法 map 来说，它就要比纯循环语句实现迭代慢 8 倍。
2、资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收（Garbage Collection）所产生的压力远远超过其他编程方式
3、在函数式编程中，为了实现迭代，通常会采用递归操作，为了减少递归的性能开销，我们往往会把递归写成尾递归形式，以便让解析器进行优化。但是众所周知，JS 是不支持尾递归优化的（虽然 ES6 中将尾递归优化作为了一个规范，但是真正实现的少之又少



