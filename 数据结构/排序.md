总结

一、排序方法与复杂度归类
（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。
（2）复杂度归类
冒泡排序、插入排序、选择排序 O(n^2)
快速排序、归并排序 O(nlogn)
计数排序、基数排序、桶排序 O(n)

二、如何分析一个“排序算法”？
<1>算法的执行效率

1. 最好、最坏、平均情况时间复杂度。
2. 时间复杂度的系数、常数和低阶。
3. 比较次数，交换（或移动）次数。
   <2>排序算法的稳定性
4. 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
5. 稳定性重要性：可针对对象的多种属性进行有优先级的排序。
6. 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。
   <3>排序算法的内存损耗
   原地排序算法：特指空间复杂度是 O(1)的排序算法。

三、冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。
稳定性：冒泡排序是稳定的排序算法。
空间复杂度：冒泡排序是原地排序算法。
时间复杂度：

1. 最好情况（满有序度）：O(n)。
2. 最坏情况（满逆序度）：O(n^2)。
3. 平均情况：
   “有序度”和“逆序度”：对于一个不完全有序的数组，如 4，5，6，3，2，1，有序元素对为 3 个（4，5），（4，6），（5，6），有序度为 3，逆序度为 12；对于一个完全有序的数组，如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。
   最好情况下初始有序度为 n*(n-1)/2，最坏情况下初始有序度为 0，则平均初始有序度为 n*(n-1)/4，即交换次数为 n*(n-1)/4，因交换次数<比较次数<最坏情况时间复杂度，所以平均时间复杂度为 O(n^2)。
```
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let ifSwap = false;
    for (let j = len-1; j > i; j--) {
      if (arr[j] < arr[j - 1]) {
        swap(arr, j, j - 1);
        ifSwap = true;
      }
    }
    if(!ifSwap){
      break;
    }
  }
  return arr;
}
```
四、插入排序
插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。
空间复杂度：插入排序是原地排序算法。
时间复杂度：

1. 最好情况：O(n)。
2. 最坏情况：O(n^2)。
3. 平均情况：O(n^2)（往数组中插入一个数的平均时间复杂度是 O(n)，一共重复 n 次）。
   稳定性：插入排序是稳定的排序算法。
```
function insertSort(arr) {
  const len = arr.length;
  for (let i = 1; i < len; i++) {
    const temp = arr[i];
    let j;
    for (j = i - 1; j >= 0; j--) {
      if (arr[j] <= temp) {
        break;
      } else {
        arr[j + 1] = arr[j];
      }
    }
    arr[j + 1] = temp;
  }
  return arr;
}
```
五、选择排序
选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。
空间复杂度：选择排序是原地排序算法。
时间复杂度：（都是 O(n^2)）

1. 最好情况：O(n^2)。
2. 最坏情况：O(n^2)。
3. 平均情况：O(n^2)。
   稳定性：选择排序不是稳定的排序算法。
```
// 选择排序
function selectSort(arr) {
  let i = 0;
  let len = arr.length;
  while (i < len) {
    let min = i;
    for (let k = i + 1; k < len; k++) {
      if (arr[k] < arr[min]) {
        min = k;
      }
    }
    swap(arr, i++, min);
  }
  return arr;
}
console.log(selectSort([11, 63, 11, 6, 42, 5, 4, 3, 7]));
```
思考
选择排序和插入排序的时间复杂度相同，都是 O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？
答：从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。
五、归并排序
原理：如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧
归并排序的性能分析：
（1）稳定性：值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。
（2）非原地排序：因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。

- 时间复杂度： O(nlogn)
  归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
- 空间复杂度：O（n)
  在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

```
function mergeSort(arr) {
  const len = arr.length;
  if (arr.length <= 1) {
    return arr;
  }
  const mid = Math.floor(len / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  return mergeArr(mergeSort(left), mergeSort(right));
}
function mergeArr(arr1, arr2) {
  console.log(arr1, arr2, "俩了");
  const tempArr = [];
  const len1 = arr1.length;
  const len2 = arr2.length;
  let i = 0;
  let j = 0;
  let k = 0;
  while (i < len1 && j < len2) {
    if (arr1[i] <= arr2[j]) {
      tempArr[k++] = arr1[i++];
      console.log(i, "i");
    } else {
      tempArr[k++] = arr2[j++];
    }
  }
  while (i < len1) {
    tempArr[k++] = arr1[i++];
  }
  while (j < len2) {
    tempArr[k++] = arr2[j++];
  }
  return tempArr;
}
```

六、快速排序
原理：快排利用的也是分治思想
如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。
```
// 快速排序
function quickSort(arr) {
  quickSortHelp(arr, 0, arr.length - 1);
  return arr;
}
function quickSortHelp(arr, start, end) {
  if (start >= end) {
    return;
  }
  const part = partition(arr, start, end);
  quickSortHelp(arr, start, part - 1);
  quickSortHelp(arr, part + 1, end);
}
function partition(arr, start, end) {
  const pivot = arr[end];
  let i = start;
  let j = start;
  while (j < end) {
    if (arr[j] < pivot) {
      swap(arr, i++, j);
    }
    j++;
  }
  swap(arr, i, j);
  return i;
}
function swap(arr, i, j) {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```
#### 分区函数的思想

partition(A, p, r) {
pivot := A[r]
i := p
for j := p to r-1 do {
if A[j] < pivot {
swap A[i] with A[j]
i := i+1
}
}
swap A[i] with A[r]
return i
通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。
![图解](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg)

#### 性能分析

（1）稳定性：在经过第一次分区操作之后，相等的值 的相对先后顺序可能就会改变。所以，快速排序并不是一个稳定的排序算法。
（2）原地排序

时间复杂度：O（nlogn）
时间复杂度和选取的 pivot 有关
最坏的情况的时间复杂度：
如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。

### 归并排序和快速排序思想的区别

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

思考题
如何求无序数组
O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。我们选择数组区间 A[0...n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，我们再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0...p-1]区间查找。
